<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Termometr DIY</title>
    <style>
        body { font-family: monospace; background: #222; color: #0f0; padding: 20px; }
        .data-box { border: 1px solid #444; padding: 15px; margin-top: 20px; border-radius: 8px; }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; color: #fff; }
        .value { font-size: 2.5rem; font-weight: bold; }
        .label { color: #888; font-size: 0.9rem; }
        button { background: #007bff; color: white; border: none; padding: 12px 24px; font-size: 1rem; border-radius: 5px; cursor: pointer; width: 100%; }
        #log { font-size: 0.8rem; color: #666; margin-top: 20px; height: 100px; overflow-y: scroll; border-top: 1px solid #333; }
    </style>
</head>
<body>

    <button id="scanBtn">START SCANNING</button>

    <div id="display" style="display:none;">
        <div class="data-box">
            <div class="label">Temperatura</div>
            <div class="value"><span id="temp">--</span>°C</div>
        </div>
        <div class="data-box">
            <div class="label">Wilgotność</div>
            <div class="value"><span id="hum">--</span>%</div>
        </div>
        <div class="data-box">
            <div class="label">Bateria</div>
            <div class="value" style="font-size: 1.5rem;"><span id="batt">--</span>% (<span id="volt">--</span>mV)</div>
        </div>
        <div class="label" style="margin-top:10px;">Ostatni odczyt: <span id="lastup">--</span></div>
    </div>

    <div id="log"></div>

    <script>
        const scanBtn = document.getElementById('scanBtn');
        const logDiv = document.getElementById('log');

        const log = (msg) => {
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML = `[${time}] ${msg}<br>` + logDiv.innerHTML;
        };

        scanBtn.addEventListener('click', async () => {
            try {
                log('Inicjalizacja skanowania...');
                
                // POPRAWKA: Musimy jawnie poprosić o dostęp do serwisu 0x181a w optionalServices.
                // Bez tego 'serviceData' będzie puste!
                const device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { namePrefix: 'ATC' },      // Często po flashu nazwa to ATC_xxxx
                        { namePrefix: 'LYWSD03' },  // Lub oryginalna
                        { services: [0x181a] }      // Lub po serwisie
                    ],
                    optionalServices: [0x181a]      // <--- KLUCZOWE DLA ODPOWIEDZI
                });

                log(`Połączono z obiektem JS: ${device.name}`);
                log(`ID: ${device.id}`);
                
                document.getElementById('display').style.display = 'block';
                scanBtn.style.display = 'none';

                // Nasłuchiwanie
                device.addEventListener('advertisementreceived', (event) => {
                    // Logujmy raz na jakiś czas, żeby widzieć że żyje
                    // console.log(event.serviceData); 

                    // Szukamy UUID 0x181a (Environmental Sensing)
                    // Chrome może zwracać UUID w formie 16-bit lub pełnej 128-bit
                    let data = event.serviceData.get(event.serviceUuids.find(uuid => uuid.includes('181a')));
                    
                    if (data) {
                        parseATC1441(data);
                    } else {
                        // Jeśli tu wpada, to znaczy że device nadaje, ale nie widzimy payloadu
                        // Może nadawać w formacie Xiaomi (0xfe95)?
                        console.warn("Odebrano pakiet, ale brak danych dla 0x181a");
                    }
                });

                // Start nasłuchiwania
                await device.watchAdvertisements();
                log('Nasłuchiwanie aktywne. Czekam na ramki...');

            } catch (error) {
                log(`Błąd: ${error}`);
                console.error(error);
            }
        });

        function parseATC1441(dataView) {
            // Format ATC1441 (Little Endian vs Big Endian to częsta pułapka)
            // Firmware pvvx w trybie ATC zazwyczaj wysyła:
            // Byte 6-7: Temp (Int16 Big Endian)
            // Byte 8: Humi (Uint8)
            // Byte 9: Batt (Uint8)
            // Byte 10-11: Volt (Uint16 Big Endian)

            if (dataView.byteLength < 10) return;

            // Sprawdzamy czy magic bytes się zgadzają, albo po prostu rzutujemy na pałę
            // W JS DataView.getInt16(offset, littleEndian) -> false = Big Endian
            const tempRaw = dataView.getInt16(6, false); 
            const temp = tempRaw / 10;
            const hum = dataView.getUint8(8);
            const batt = dataView.getUint8(9);
            const volt = dataView.getUint16(10, false);

            updateUI(temp, hum, batt, volt);
        }

        function updateUI(temp, hum, batt, volt) {
            document.getElementById('temp').innerText = temp.toFixed(1);
            document.getElementById('hum').innerText = hum;
            document.getElementById('batt').innerText = batt;
            document.getElementById('volt').innerText = volt;
            document.getElementById('lastup').innerText = new Date().toLocaleTimeString();
        }
    </script>
</body>
</html>
